# 锁
Java程序中使用锁来保证代码块对某个资源独占使用，确保程序不会因为其他进程而导致读取到脏数据。

## 死锁
简单的来说 两个进程为争夺对方持有的资源，互相等待的情况，形成了死锁。

### 死锁的4个条件
- 互斥条件（一个资源每次只能被一个进程使用，即在一段时间内某 资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。）
- 请求与保持条件（进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源 已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。）
- 不可剥夺条件（进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能 由获得该资源的进程自己来释放（只能是主动释放)。）
- 循环等待条件（若干进程间形成首尾相接循环等待资源的关系）


### 死锁避免
死锁避免的基本思想：系统对进程发出的每一个系统能够满足的资源申请进行动态检查，并根据检查结果决定是否分配资源，
如果分配后系统可能发生死锁，则不予分配，否则予以分配，这是一种保证系统不进入死锁状态的动态策略。 

### 死锁预防
我们可以通过破坏死锁产生的4个必要条件来 预防死锁，由于资源互斥是资源使用的固有特性是无法改变的。

- 破坏“不可剥夺”条件：一个进程不能获得所需要的全部资源时便处于等待状态，等待期间他占有的资源将被隐式的释放重新加入到 系统的资源列表中，可以被其他的进程使用，而等待的进程只有重新获得自己原有的资源以及新申请的资源才可以重新启动，执行。
- 破坏”请求与保持条件“：第一种方法静态分配即每个进程在开始执行时就申请他所需要的全部资源。第二种是动态分配即每个进程在申请所需要的资源时他本身不占用系统资源。
- 破坏“循环等待”条件：采用资源有序分配其基本思想是将系统中的所有资源顺序编号，将紧缺的，稀少的采用较大的编号，在申请资源时必须按照编号的顺序进行，一个进程只有获得较小编号的进程才能申请较大编号的进程。

### 检查死锁的方法
https://www.cnblogs.com/itsoku123/p/10974157.html
- jstack
- jconsole
- visualVM


### DeadLockDemo
展示死锁产生的Demo。

### ResourceOrderlyAssignment
有序资源排序法，避免死锁的一种处理方法